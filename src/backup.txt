const express = require("express");
const { Client, LocalAuth } = require("whatsapp-web.js");
const qrcode = require("qrcode-terminal");
const { Server } = require("socket.io");
const http = require("http");
const cors = require("cors");
const app = express();
const server = http.createServer(app);
const io = new Server(server);
const axios = require("axios");

const { Buttons } = require('whatsapp-web.js');
// Middleware para parsear JSON
app.use(express.json()); // Esto es necesario para leer los cuerpos JSON en las solicitudes POST

app.use(express.static("public"));

const corsOptions = {
  origin: "http://localhost:4300", // Permite solicitudes solo desde esta URL
  methods: "GET,POST,PUT,DELETE", // M√©todos permitidos
  allowedHeaders: "Content-Type, Authorization", // Encabezados permitidos
};

// Habilitar CORS con la configuraci√≥n
app.use(cors(corsOptions));

// Configuraci√≥n del cliente WhatsApp
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    headless: true, // Si prefieres ver el navegador, ponlo en 'false'
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  },
});

// const client = new Client({
//   authStrategy: new LocalAuth(),
//   puppeteer: {
//     headless: false, // Cambia a 'false' para ver el navegador
//     args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-extensions', '--remote-debugging-port=9222']
//   }
// });

app.get("/whatsapp-status", async (req, res) => {
  try {
    const state = await client.getState();
    res.json({
      status: "ok",
      connection: state,
      info: client.info
        ? {
            wid: client.info.wid._serialized,
            pushname: client.info.pushname,
          }
        : null,
    });
  } catch (err) {
    res.status(200).json({
      status: "desconectado",
      connection: "NOT_CONNECTED",
      error: err.message,
    });
  }
});

let chatsCache = [];
let contactosCache = []; // Guardar contactos para no consultarlos cada vez

app.get('/contactos', (req, res) => {
    if (contactosCache.length === 0) {
        return res.status(500).json({ mensaje: 'Contactos no disponibles a√∫n. ¬øEscaneaste el QR?' });
    }

    const data = contactosCache.map(c => ({
        id: c.id._serialized,
        nombre: c.name || c.pushname || '',
        numero: c.number,
        esGrupo: c.isGroup
    }));

    res.json(data);
});

// Ruta para enviar botones
app.post('/send-buttons', async (req, res) => {
    const { number, message, buttons, title, footer } = req.body;

    if (!number || !buttons) {
        return res.status(400).json({ error: 'Faltan datos obligatorios' });
    }

    try {
        const chatId = number.includes('@c.us') ? number : number + '@c.us';

        const buttonMessage = new Buttons(message || 'Selecciona una opci√≥n', buttons, title || 'Opciones', footer || '');

        await client.sendMessage(chatId, buttonMessage);

        res.status(200).json({ status: 'Enviado con √©xito' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Error al enviar mensaje' });
    }
});


app.get("/whatsapp-disconnect", async (req, res) => {
  try {
    await client.destroy(); // Cierra sesi√≥n y termina la conexi√≥n

    res.json({
      status: "ok",
      message: "Cliente de WhatsApp desconectado",
    });
  } catch (err) {
    res.status(500).json({
      status: "error",
      message: "Error al desconectar cliente",
      error: err.message,
    });
  }
});

app.get("/whatsapp-reconnect", async (req, res) => {
  try {
    await client.destroy(); // Cierra cualquier instancia previa
    await client.initialize(); // Re-inicia el cliente

    res.json({
      status: "ok",
      message: "Cliente de WhatsApp reiniciado",
    });
  } catch (err) {
    res.status(500).json({
      status: "error",
      message: "Error al reiniciar cliente",
      error: err.message,
    });
  }
});

// Este evento se dispara cuando se genera un QR
client.on("qr", (qr) => {
  // Mostrar el QR en consola
  qrcode.generate(qr, { small: true }); // Muestra el QR como caracteres en consola
  io.emit("qr", qr); // Tambi√©n lo emite para mostrarlo en la web
});

client.on("disconnected", () => {
  console.log("X Cliente Desconectado");
});

client.on("disconnected", (reason) => {
  console.warn("‚ö† Cliente desconectado:", reason);
});

app.get("/chat/:numero", async (req, res) => {
  const numero = req.params.numero;

  // Asegurar formato correcto para WhatsApp
  const chatId = ${numero}@c.us;

  try {
    const chat = await client.getChatById(chatId);

    // Cargar √∫ltimos mensajes del chat
    const mensajes = await chat.fetchMessages({ limit: 20 });

    // Formatear para enviar como JSON
    const historial = mensajes.map((m) => ({
      id: m.id._serialized, // ID √∫nico del mensaje
      de: m.fromMe ? "yo" : m.author || m.from,
      texto: m.body,
      estado: m.ack,
      //fecha: new Date(m.timestamp * 1000).toLocaleString(),
      fecha: m.timestamp,
    }));

    res.json({
      status: "ok",
      numero: numero,
      mensajes: historial,
    });
  } catch (err) {
    res.status(404).json({
      status: "error",
      mensaje: No se pudo obtener el chat de ${numero},
      error: err.message,
    });
  }
});

// Enviar un mensaje desde el backend
app.post("/send-message", (req, res) => {
  const { to, message } = req.body; // 'to' es el n√∫mero al que enviamos, 'message' es el contenido

  const number = to + "@c.us"; // Formato de n√∫mero en WhatsApp
  client
    .sendMessage(number, message)
    .then((response) => {
      res.send({ status: "success", response });
    })
    .catch((err) => {
      res.status(500).send({ status: "error", message: err.message });
    });
});

// client.on('message', msg => {
//   io.emit('message', {
//     from: msg.from,
//     body: msg.body
//   });
// });

app.post("/notificar", (req, res) => {
  const { titulo, mensaje, data } = req.body;

  if (!data) {
    return res.status(400).json({
      status: "error",
      message: "El campo 'data' es requerido",
    });
  }

  io.emit("notificacion", {
    titulo,
    mensaje,
    data,
    timestamp: new Date().toISOString(),
  });

  res.send({ status: "ok", message: "Notificaci√≥n enviada", enviado: data });
});

client.on("message_ack", (msg, ack) => {
  const data = {
    id: msg.id._serialized, // ID del mensaje
    numero: msg.to, // N√∫mero al que se le envi√≥ el mensaje
    mensaje: msg.body, // Texto del mensaje
    ackStatus: ack, // Estado del mensaje (0, 1, 2, 3)
    timestamp: new Date().toISOString(), // Hora actual
  };

  // console.log('Estado de mensaje:', data);

  // Emitir los cambios de estado del mensaje al frontend
  io.emit("message_ack_status", data);
});

const contactosRegistrados = new Set(); // Guarda n√∫meros ya registrados




app.post("/entrenarModelo", async (req, res) => {
  const { mensaje } = req.body;

  try {
    const resultado = await responderConIAv1(mensaje);

    // Validar si el modelo devolvi√≥ JSON v√°lido
    let datosIA;
    try {
      datosIA = JSON.parse(resultado);
    } catch (error) {
      return res.send({
        status: "error",
        message: "La IA no devolvi√≥ un JSON v√°lido",
        respuestaIA: resultado
      });
    }

    // Aqu√≠ podr√≠as ejecutar la acci√≥n en tu backend
    if (datosIA.accion === "REGISTRAR_CONTACTO") {
      console.log("Acci√≥n: Registrar contacto");
      // Llamada a tu l√≥gica de backend
    } else if (datosIA.accion === "REGISTRAR_CONTACTO_ETAPA") {
      console.log(Acci√≥n: Registrar contacto en etapa de campa√±a ${datosIA.idCampania});
      // Llamada a tu l√≥gica de backend
    }

    res.send({
      status: "ok",
      message: "Procesado correctamente",
      accion: datosIA.accion,
      idCampania: datosIA.idCampania,
      respuestaUsuario: datosIA.respuesta
    });
  } catch (error) {
    res.status(500).send({
      status: "error",
      message: "Error procesando el mensaje",
      error: error.message
    });
  }
});


client.on("message", async (msg) => {
  console.log(Mensaje recibido de ${msg.from}: ${msg.body});

  if (msg.from.includes("@g.us") || msg.from === "status@broadcast") {
    // Ignorar si es de un grupo o estado
    return;
  }

  const contacto = await msg.getContact();
  const numero = contacto.number.startsWith("51")
    ? contacto.number
    : "51" + contacto.number;
 
  const respuesta = await responderConIAv2(msg.body);
  if (respuesta) {
    msg.reply(respuesta);
  } else {
    msg.reply("Lo siento, no pude responder en este momento.");
  }



    switch (resultado.accion) {
    case "REGISTRAR_CONTACTO":
      // Guardar contacto sin campa√±a
     
      msg.reply("registrar contacto?");
      break;
    case "REGISTRAR_CONTACTO_ETAPA":
      // Guardar contacto con campa√±aId
      
      msg.reply(registrar contacto con etapada);
      break;
    default:
      msg.reply("Disculpa, no pude procesar tu mensaje.");
  }



 
});



async function responderConIAv2(pregunta) {
  const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
        "Authorization": "Bearer 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",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "mistralai/mistral-7b-instruct",
      messages: [
        {
          role: "system",
          content: `Eres un asistente que recibe mensajes de usuarios y detecta la acci√≥n que debe tomar el backend. \
Si el mensaje es un saludo o frase gen√©rica, devuelve este JSON exacto: {"accion":"REGISTRAR_CONTACTO"}. \
Si el mensaje menciona alguna campa√±a de esta lista: 1: Preventa VibesFest, 2: Rock en el Bar, 3: Auspicio Locales, \
devuelve este JSON exacto: {"accion":"REGISTRAR_CONTACTO_ETAPA", "campa√±aId":ID}. \
Siempre responde SOLO con un JSON v√°lido, sin texto adicional.`
        },
        {
          role: "user",
          content: pregunta
        }
      ]
    })
  });

  const data = await response.json();

  try {
    return JSON.parse(data.choices[0].message.content);
  } catch {
    return null; // O manejar error
  }
}

// En el manejador de mensajes:
client.on("message", async (msg) => {
  if (msg.from.includes("@g.us") || msg.from === "status@broadcast") return;

  const contacto = await msg.getContact();
  const numero = contacto.number.startsWith("51") ? contacto.number : "51" + contacto.number;

  const resultado = await responderConIA(msg.body);

  if (!resultado) {
    return msg.reply("No entend√≠ tu mensaje, por favor intenta nuevamente.");
  }

  switch (resultado.accion) {
    case "REGISTRAR_CONTACTO":
      // Guardar contacto sin campa√±a
      guardarContacto(numero, contacto.pushname || contacto.number);
      msg.reply("¬°Hola! Gracias por escribirnos. ¬øEn qu√© puedo ayudarte?");
      break;
    case "REGISTRAR_CONTACTO_ETAPA":
      // Guardar contacto con campa√±aId
      guardarContactoConCampa√±a(numero, contacto.pushname || contacto.number, resultado.campa√±aId);
       
      break;
    default:
      msg.reply("Disculpa, no pude procesar tu mensaje.");
  }
});



client.on("messagev2", async (msg) => {
  console.log(Mensaje recibido de ${msg.from}: ${msg.body});

  if (msg.from.includes("@g.us") || msg.from === "status@broadcast") {
    // Ignorar si es de un grupo o estado
    return;
  }

  const contacto = await msg.getContact();
  const numero = contacto.number.startsWith("51")
    ? contacto.number
    : "51" + contacto.number;

  

  const respuesta = await responderConIA(msg.body);
  if (respuesta) {
    msg.reply(respuesta);
  } else {
    msg.reply("Lo siento, no pude responder en este momento.");
  }

  io.emit("message", {
    id: msg.id.id,
    from: msg.from,
    body: msg.body,
  });

  if (contactosRegistrados.has(numero)) {
    return;
  }

  const data = {
    NombreContacto: contacto.pushname || contacto.name || "SinNombre",
    ApellidoPaterno: "",
    ApellidoMaterno: "",
    Celular: numero,
    Email: "--",
    Origen: "WA",
    TipoDocumento: "--",
    NroDocumento: "--",
    Estado: "NU",
  };

  // Enviar al backend

  try {
    const response = await axios.post(
      "http://localhost:44305/apiv3/Contactos/create",
      data,
      {
        headers: {
          Authorization: Bearer CLAVESECRETA_SUFICIENTEMENTE_LARGA,
        },
      }
    );
    // Marcamos como ya registrado
    contactosRegistrados.add(numero);

    if (response.status === 200) {
      io.emit("resfreshcontacto", {
        data,
        mensaje: "Contacto guardado correctamente",
      });
    }

    console.log("üì• Contacto enviado:", response.data);
  } catch (error) {
    if (error.response && error.response.status === 409) {
      contactosRegistrados.add(numero);
      console.log("üìå Contacto ya existe, no se registr√≥ nuevamente.");
      return;
    }

    console.error("‚ùå Error al guardar el contacto:", error.message);
  }
});



const fetch = require("node-fetch");

async function responderConIAv1(pregunta) {
  const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": "Bearer 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",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "mistralai/mistral-7b-instruct",
      messages: [
        {
          role: "system",
          content: `
          Eres un asistente virtual de VibesFest.
          Analiza el mensaje del usuario y devuelve SOLO un JSON as√≠:
          {
            "accion": "REGISTRAR_CONTACTO" | "REGISTRAR_CONTACTO_ETAPA" | null,
            "idCampania": <n√∫mero o null>,
            "respuesta": "<texto breve para el usuario o null si no hay respuesta>"
          }

          Reglas:
          - Saludo o conversaci√≥n general sobre VibesFest ‚Üí accion: "REGISTRAR_CONTACTO", idCampania: null.
          - Pregunta sobre eventos, fechas, precios, bandas o campa√±as ‚Üí accion: "REGISTRAR_CONTACTO_ETAPA" con idCampania correspondiente.
          - Mensaje fuera de contexto (no relacionado con m√∫sica, eventos o VibesFest) ‚Üí accion: null, idCampania: null, respuesta: null.
          Campa√±as:
            1: Preventa VibesFest - venta anticipada de entradas.
            2: Rock en el Bar - promoci√≥n evento rock.
          No devuelvas nada fuera del JSON. Si no hay acci√≥n, usa null en "accion".
          `
        },
        {
          role: "user",
          content: pregunta
        }
      ]
    })
  });

  const data = await response.json();
  return data.choices[0]?.message?.content;
}

async function responderConIA(pregunta) {
  const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": "Bearer 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",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "mistralai/mistral-7b-instruct", // o "meta-llama/llama-3-8b-instruct"
      messages: [
        {
          role: "system",
          "content": "Eres un asistente virtual de VibesFest, un organizador de eventos de m√∫sica rock y alternativa en locales de Barranco, Per√∫, como El Tayta y Lice Iana Rock. Tu misi√≥n es responder preguntas de forma breve, clara y √∫til. Responde en una o dos frases m√°ximo. S√© directo y amigable. No repitas la pregunta del usuario. Si no tienes la informaci√≥n, sugiere contactar a Nick Pasco o visitar Instagram @vibesfest.peru. Responde dudas sobre fechas de eventos, precios, participaci√≥n de bandas, detalles de locales, y redes sociales. No uses p√°rrafos largos ni explicaciones innecesarias."
        },
        {
          role: "user",
          content: pregunta
        }
      ]
    })
  });

  const data = await response.json();
  return data.choices[0]?.message?.content;
}

app.get('/chats-contactos', (req, res) => {
    if (chatsCache.length === 0) {
        return res.status(500).json({ mensaje: 'Chats no disponibles a√∫n. ¬øEscaneaste el QR?' });
    }

    const data = chatsCache
        .filter(chat => !chat.isGroup) // solo chats privados
        .map(chat => ({
            id: chat.id._serialized,
            nombre: chat.name || chat.contact?.pushname || '',
            numero: chat.id.user,
            esGrupo: chat.isGroup,
            ultimaActividad: chat.timestamp
        }));

    res.json(data);
});

client.on("ready", async  () => {
  console.log("‚úÖ Cliente conectado");
   contactosCache = await client.getContacts();
     chatsCache = await client.getChats();
  io.emit("ready");
});

client.on("auth_failure", (msg) => {
  console.error("‚ùå Error de autenticaci√≥n:", msg);
});

client.on("disconnected", (reason) => {
  console.warn("‚ö† Cliente desconectado:", reason);
});

// Inicializa el cliente de WhatsApp
client.initialize();

server.listen(3000, () => {
  console.log("Servidor corriendo en http://localhost:3000");
});